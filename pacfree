#!/usr/bin/env bash

				####################################
				#             PACFREE              #
				#  The free-software aware pacman  #
				####################################

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#  


### DESCRIPTION ###

# Pacman wrapper to make pacman free-software aware. This script
#+ checks all packages to be installed against Parabola's blacklist,
#+ warns the user if the package is non-free, and then, if the user
#+ accepts, installs the corresponding package. It also includes a
#+ rules file to choose repos on a per package basis (both for
#+ upgrades and new packages installation)

#+ Built-in pacfree operations:
#+ [package(s)] (No operation amounts to -Syu [PKG(S)])
#+ -f | --check-free (check for non-free packages)
#+ -L | --add-repo (Add and enable libre repositories)
#+ -x | --del-repo (Disable libre repositories)
#+ -r | --list-repos (List currently enabled repos)
#+ -a | --add-rule (Add new repo rule)
#+ -d | --del-rule (Remove repo rule)
#+ -l | --list-rules (List current rules)

### TODO LIST ###

# 1) Package managers different to pacman and powerpill will most
#+ likely fail (because of having different options). DO NOT ALLOW
#+ THE USE OF DIFFERENT PAC-MANS
# 2) Make isfree use the same blacklist filenames as pacfree
# 3) As far as I know, there is only one unsupported operation: -Suu
#+ (allow downgrades). 

### COLORS ###

yellow='\033[1;33m'
green="\033[1;32m"
red="\033[1;31m"
blue="\033[1;34m"
bold='\033[1m'
nc="\033[0m"

### PROGRAM DATA ###

ME="PacFree"
VERSION="0.6.2"
AUTHOR="L. Abramovich"
DATE="Jul 25, 2022"
LICENSE="GPL2"
WEBSITE="https://github.com/leo-arch/pacfree"

### BLACKLISTS ###

BLACKLIST_SOURCE="https://git.parabola.nu/blacklist.git/plain/blacklist.txt"
BLACKLIST_FILE="/tmp/pkgs_blacklist"

BLACKLIST_SOURCE_AUR="https://git.parabola.nu/blacklist.git/plain/aur-blacklist.txt"
BLACKLIST_FILE_AUR="/tmp/pkgs_blacklist_aur"

### PACMAN CONFIG FILE ###

PACMAN_CONF_FILE="/etc/pacman.conf"

### EXIT CODES ###

EXIT_SUCCESS=0
EXIT_FAILURE=1


					##########################
					#       FUNCTIONS        #
					##########################

################################

echoerr ()
{
	echo -e "$@" >&2
}

################################

help ()
{
	# $arg will be local and read-only
	declare -r arg="$1"

	case $arg in
		help)

			if [[ $PACMAN != "pacman" ]]; then
				/usr/bin/"$PACMAN" -h
			else
				echo -e "$ME, the free-software aware pacman" \
						"\n\nDescription:" \
						"\nWhenever a package is to be installed, $ME" \
						"checks the package against Parabola's" \
						"blacklists, and, if blacklisted, warns" \
						"the user and let her choose whether to" \
						"continue installing the package or not. Via the" \
						"rules list, it also allows to choose repositories" \
						"on a per package basis. In this way, a ruled" \
						"package will always be installed/upgraded from" \
						"the specified repository, disregarding the" \
						"repositories order in pacman configuration file" \
						"\n\nUsage:" \
						"\n    ${ME,,} <package(s)>" \
						"\n    ${ME,,} <operation> [...]\n"

				echo -e "Operations:
    ${ME,,} {-h --help}
    ${ME,,} {-V --version}
    ${ME,,} {-D --database}       <options> <package(s)>
    ${ME,,} {-F --files}          [options] [package(s)]
    ${ME,,} {-Q --query}          [options] [package(s)]
    ${ME,,} {-R --remove}         [options] <package(s)>
    ${ME,,} {-S --sync}           [options] [package(s)]
    ${ME,,} {-T --deptest}        [options] [package(s)]
    ${ME,,} {-U --upgrade}        [options] <file(s)>"

			fi

echo -e "\n$ME specific operations:
    ${ME,,} {-f --check-free}     [package(s)]
    ${ME,,} {-l --list-rules}
    ${ME,,} {-a --add-rule}       <rule(s)>
    ${ME,,} {-d --del-rule}       <rule(s)>
    ${ME,,} {-L --add-repo}       [repo(s)]
    ${ME,,} {-x --del-repo}       <repo(s)>
    ${ME,,} {-r --list-repos}     [repo(s)]
    ${ME,,} {-u --upgrademe}

Use '${ME,,} {-h --help}' with an operation for more information

Use --color=never or -nc to disable colored output

Use  -b or --full-blacklist to use Parabola's full blacklist instead \
of the reduced version used by default. For more information consult \
the manpage

For those users coming from Debian/RedHat based systems, the following \
APT/DNF-like syntax (and its abbreviated form) is recognized (the \
pacman/${ME,,} equivalent is provided in parentheses and is always the \
recommended way to go):

    install,i (-S)
    install-local,il (-U)
    remove,r (-Rns)
    update,refresh,u (-Sy)
    upgrade,sysupgrade,s (-Syu)
    search,query,q (-Ss)
    list-installed,li (-Qe)
    list-installed-native,lin (-Qen)
    list-installed-foreign,lif (-Qem)
    list-installed-deps,lid (-Qd)
    list-no-required,lnr (-Qt)
    list-updates,lu (sudo pacman -Sy && pacman -Qu)
    info,n (-Qi)
    info-remote,nr (-Si)
    list-files,lf (-Ql)
    provides,p (-Qo)
    provides-remote,pr (-F)
    check,k (-Qk)
    clean,c (-Sc)
    clean-all,ca (-Scc)
    download,d (-Sw)
    history,logs,l [pkg ...] (grep \"pkg ...\" /var/log/pacman.log)
    list-repos,lr ('pacfree -r' or 'pacman-conf -l' )
    check-free,cf (pacfree -f)
    add-rule,ar (pacfree -a)
    del-rule,dl (pacfree -d)
    list-rules,lr (pacfree -l)
    add-repo,al (pacfree -L)
    del-repo,dl (pacfree -x)
    list-repos,ll (pacfree -r or pacman-conf -l)
    help (-h)
    version (-V)"
		;;

		checkfree)
			echo -e "Check package(s) against blacklists" \
					"\nWith no argument, lists all non-free installed" \
					"packages. Else, it checks packages specified as" \
					"further arguments against the blacklists" \
					"\nUsage: ${ME,,} {-f --check-free} [packages(s)]"
		;;

		addrule)
			echo -e "Add new rules to the rules list" \
					"(~/.config/${ME,,}/rules.conf)" \
					"\nIf a rule, always in the form \"repo/pkg\", is" \
					"added to the rules list for a given package, this" \
					"package will always be installed/upgraded from the" \
					"specified repository, disregarding the repositories" \
					"order in '$PACMAN_CONF_FILE'" \
					"\nUsage: ${ME,,} {-a --add-rule} <repo/pkg> ...\n"
		;;

		delrule)
			echo -e "Remove rules from the rules list" \
					"\nUsage: ${ME,,} {-d --del-rule} [rule(s)]"
		;;

		listrules)
			echo -e "List currently enabled rules" \
					"\nUsage: ${ME,,} {-l --list-rules}"
		;;

		addrepo)
			echo -e "Add and enable free/libre repositories (Parabola)" \
					"\nWith no argument, the user will be asked whether to" \
					"enable or not each of the libre repositories." \
					"Otherwise, only repositories specified as arguments" \
					"will be added. Valid repositories are: libre, pcr," \
					"kernels, cross, nonprism, libre-multilib," \
					"libre-testing, pcr-testing, libre-multilib-testing," \
					"and nonprism-testing" \
					"\nUsage: ${ME,,} {-L --add-repo} [repo(s)]"
		;;

		delrepo)
			echo -e "Disable libre repositories specified as further" \
					"arguments" \
					"\nUsage: ${ME,,} {-x --del-repo} <repo(s)>"
		;;

		listrepos)
			echo -e "List currently enabled repositories or check" \
					"repositories specified as further arguments" \
					"\nUsage: ${ME,,} {-r --list-repos} <repo(s)>"
		;;

		upgrademe)
			echo -e "Check current upstream version" \
					"\nUsage: ${ME,,} {-u --upgrademe}"
		;;

		fullblacklist)
			echo -e "Use Parabola's full blacklist instead of the " \
					"trimmed down one. By default, $ME removes from this" \
					"blacklist packages blacklisted merely because of" \
					"branding and/or technical issues, like 'pacman'," \
					"'grub' or 'filesystem', simply because they are in" \
					"themselves free." \
					"\nUsage: ${ME,,} {-b --full-blacklist}"
		;;
	esac
}

################################

is_ignored ()
{
	local name="$1"
	for ign_pkg in ${IGNORED[*]}; do
		[[ "$ign_pkg" == "$name" ]] && return $EXIT_SUCCESS
	done

	return $EXIT_FAILURE
}

check_sys_free ()
{
	if [[ ${#IGNORED[@]} -eq 0 && "$(type -P /usr/bin/isfree)" ]]; then
		local options=""
		[[ $full_blacklist -eq 1 ]] && options="-t"
		[[ $color_ok -eq 1 ]] && options="$options -c"

		/usr/bin/isfree $options -na || exit $EXIT_FAILURE

		return
	fi

	local nonfree=0 pkg="" pkgs=() non_free_pkgs=() \
	non_free_pkgs_aur=() name alternative ref id description

	mapfile -t pkgs < <(/usr/bin/pacman -Qn | /usr/bin/awk \
	'!/\.par|\.hyperbola|_gnu/{print $1}')

	### CHECK OFFICIAL BLACKLIST ###

	echo -e "$blue::$nc$bold Checking installed packages against" \
			"the official blacklist...$nc"

	# Compare blocks of 20 pkgs AT ONCE against the blacklist
	# This is fast! But there should be a still better solution for
	#+ this

	mapfile -t non_free_pkgs < <(for ((i=0; i<${#pkgs[*]}; i=$((i+20)))); do
		/usr/bin/grep -- "^${pkgs[$i]}:\|^${pkgs[$((i+1))]}:\|^${pkgs[$((i+2))]}:\|^${pkgs[$((i+3))]}:\|^${pkgs[$((i+4))]}:\|^${pkgs[$((i+5))]}:\|^${pkgs[$((i+6))]}:\|^${pkgs[$((i+7))]}:\|^${pkgs[$((i+8))]}:\|^${pkgs[$((i+9))]}:\|^${pkgs[$((i+10))]}:\|^${pkgs[$((i+11))]}:\|^${pkgs[$((i+12))]}:\|^${pkgs[$((i+13))]}:\|^${pkgs[$((i+14))]}:\|^${pkgs[$((i+15))]}:\|^${pkgs[$((i+16))]}:\|^${pkgs[$((i+17))]}:\|^${pkgs[$((i+18))]}:\|^${pkgs[$((i+19))]}:" "$BLACKLIST_FILE" | /usr/bin/cut -d':' -f1
		done)

	for pkg in ${non_free_pkgs[*]}; do
		while IFS=':' read -r name alternative ref id description; do
			[[ $name != "$pkg" ]] && continue

			# Check ignored packages
			if is_ignored "$name"; then
				ign_list=(${ign_list[@]} "$name")
				continue
			fi

			(( nonfree++ ))
			if [[ -z $alternative ]]; then
				alternative="$(extra_alternatives "$name")"
			fi
			[[ -z $alternative ]] && alternative="None"
			echo -e "$red$name$nc: $description" \
					"\n   Free/libre alternative: $alternative"
		done < "$BLACKLIST_FILE"
	done

	### CHECK THE AUR BLACKLIST ###

	echo -e "$blue::$nc$bold Checking installed packages against" \
			"the AUR blacklist...$nc"

	mapfile -t non_free_pkgs_aur < <(for ((i=0; i<${#pkgs[*]}; i=$((i+20)))); do
		/usr/bin/grep -- "^${pkgs[$i]}:\|^${pkgs[$((i+1))]}:\|^${pkgs[$((i+2))]}:\|^${pkgs[$((i+3))]}:\|^${pkgs[$((i+4))]}:\|^${pkgs[$((i+5))]}:\|^${pkgs[$((i+6))]}:\|^${pkgs[$((i+7))]}:\|^${pkgs[$((i+8))]}:\|^${pkgs[$((i+9))]}:\|^${pkgs[$((i+10))]}:\|^${pkgs[$((i+11))]}:\|^${pkgs[$((i+12))]}:\|^${pkgs[$((i+13))]}:\|^${pkgs[$((i+14))]}:\|^${pkgs[$((i+15))]}:\|^${pkgs[$((i+16))]}:\|^${pkgs[$((i+17))]}:\|^${pkgs[$((i+18))]}:\|^${pkgs[$((i+19))]}:" "$BLACKLIST_FILE_AUR" | /usr/bin/cut -d':' -f1
		done)

	for pkg in ${non_free_pkgs_aur[*]}; do
		while IFS=':' read -r name alternative ref id description; do
			[[ $name != "$pkg" ]] && continue
			(( nonfree++ ))
			if [[ -z $alternative ]]; then
				alternative="$(extra_alternatives "$name")"
			fi
			[[ -z $alternative ]] && alternative="None"
			echo -e "$red$name$nc: $description" \
					"\n   Free/libre alternative: $alternative"
		done < "$BLACKLIST_FILE_AUR"
	done

	if [[ $nonfree -eq 0 ]]; then
		echo -e "\n${green}[+]$nc No non-free/libre packages" \
			"found. Uncle RMS smiles!"
	elif [[ $nonfree -eq 1 ]]; then
		echo -e "\n${red}[-]$nc $nonfree non-free/libre" \
			"package found"
	else
		echo -e "\n${red}[-]$nc $nonfree non-free/libre" \
			"packages found"
	fi

	if [[ "${#ign_list[@]}" -eq 1 ]]; then
		echo -e "${red}[-]$nc 1 non-free/libre ignored package:" \
			"${red}${ign_list[*]}$nc"
	elif [[ "${#ign_list[@]}" -gt 1 ]]; then
		echo -e "${red}[-]$nc ${#ign_list[@]} non-free/libre ignored packages:" \
			"${red}${ign_list[*]}$nc"
	fi
}

################################

add_libre_repos ()
{
	local missing_repo=0 libre_repos=()

	if [[ -n $1 ]]; then

		libre_repos=( "$@" )
		missing_repo=${#libre_repos[*]}

	else
		# If no argument, ask the user for each available repository
		for x in libre libre-multilib pcr kernels cross nonprism \
		libre-testing libre-multilib-testing pcr-testing nonprism-testing; do
			if [[ "$(/usr/bin/pacman-conf -r "$x" 2>/dev/null)" ]]; then
				echo -e "${green}[+]$nc The [$x] repository is" \
						"already enabled"
			else
				answer="."

				while ! [[ $answer =~ ^(y|Y|n|N|)$ ]]; do
					read -rp " Add [$x]? [y/N] " answer
				done

				case $answer in
					y|Y)
						(( missing_repo++ ))
						libre_repos[${#libre_repos[*]}]="$x"
					;;
					""|n|N) continue ;;
				esac
			fi
		done
	fi

	[[ $missing_repo -eq 0 ]] && return

	[[ -z $1 ]] && /usr/bin/sudo /usr/bin/true

	local keyring_url="https://www.parabola.nu/packages/libre/x86_64/parabola-keyring/download"
	local mirrorlist_url="https://mirror.fsf.org/parabola/mirrorlist.txt"

	if ! [[ "$(/usr/bin/pacman -Qq parabola-keyring)" ]]; then
		local RFSL_OK=0
		if /usr/bin/grep -q "^RemoteFileSigLevel = Never$" -- \
		"$PACMAN_CONF_FILE"; then
			RFSL_OK=1
		fi

		if [[ RFSL_OK -eq 0 ]]; then
			echo -e "$blue::$nc$bold Setting RemoteFileSigLevel" \
					"to Never...$nc "
			/usr/bin/sudo /usr/bin/sed -i \
			'/RemoteFileSigLevel/a RemoteFileSigLevel = Never' -- \
			"$PACMAN_CONF_FILE" || exit $EXIT_FAILURE
		fi

		echo -e "$blue::$nc$bold Installing parabola-kerying...$nc "
		/usr/bin/sudo /usr/bin/pacman -U -- "$keyring_url" \
		|| exit $EXIT_FAILURE

		if [[ RFSL_OK -eq 0 ]]; then
			echo -e "$blue::$nc$bold Reverting changes made to" \
					"RemoteFileSigLevel...$nc "
			/usr/bin/sudo /usr/bin/sed -i '/RemoteFileSigLevel = Never/d' \
			-- "$PACMAN_CONF_FILE" || exit $EXIT_FAILURE
		fi
	fi

	if ! [[ -f /etc/pacman.d/parabola_mirrorlist ]]; then
		echo -e "$blue::$nc$bold Downloading Parabola's" \
				"mirrorlist...$nc "
		/usr/bin/sudo /usr/bin/curl -so -- \
		/etc/pacman.d/parabola_mirrorlist "$mirrorlist_url" \
		|| exit $EXIT_FAILURE
	fi

	for x in ${libre_repos[*]}; do

		# If the repo has been supplied as argument, check we have a valid
		#+ repository
		if [[ -n $1 ]]; then
			case $x in
				libre|pcr|cross|kernels|nonprism|libre-multilib\
				|libre-testing|pcr-testing|nonprism-testing\
				|libre-multilib-testing) ;;
				*)
					echoerr "${ME,,}: [$x]: No such repository"
					(( missing_repo-- ))
					[[ $missing_repo -eq 0 ]] && exit $EXIT_SUCCESS
					continue
				;;
			esac
		fi

		if ! [[ "$(/usr/bin/pacman-conf -r "$x" 2>/dev/null)" ]]; then
			echo -e "$blue::$nc$bold Adding [$x] repository" \
					"to ${PACMAN_CONF_FILE}...$nc "

			echo -e "\n[$x]\nInclude =" \
					"/etc/pacman.d/parabola_mirrorlist" \
					| /usr/bin/sudo /usr/bin/tee -a -- "$PACMAN_CONF_FILE" \
					1>/dev/null || exit $EXIT_FAILURE

		elif [[ -n $1 ]]; then
			echo "${ME,,}: [$x]: Repository already enabled"
			(( missing_repo-- ))
			[[ $missing_repo -eq 0 ]] && exit $EXIT_SUCCESS
		fi

	done

#	echo -e "$blue::$nc$bold Updating pacman database...$nc "

	/usr/bin/sudo /usr/bin/pacman -Sy || exit $EXIT_FAILURE
}

################################

download_blacklist ()
{
	# If full blacklist is enabled and the current blacklist file is
	#+ not the full version, delete it
	if [[ $full_blacklist -eq 1 ]]; then
		if [[ -f $BLACKLIST_FILE ]]; then
			if ! /usr/bin/grep -q -- "^pacman:" "$BLACKLIST_FILE"; then
				/usr/bin/rm -- "$BLACKLIST_FILE"
			fi
		fi

	# If full blacklist is not enabled and the current blacklist file
	#+ is the full version, delete it
	else
		if [[ -f $BLACKLIST_FILE ]]; then
			if /usr/bin/grep -q -- "^pacman:" "$BLACKLIST_FILE"; then
				/usr/bin/rm -- "$BLACKLIST_FILE"
			fi
		fi
	fi

	if [[ -f $BLACKLIST_FILE ]]; then
		# If the blacklist file exists and it was last modified one
		#+ day ago or less, do nothing
		[[ $(($(/usr/bin/date "+%s") -  \
		$(/usr/bin/stat -c "%Y" -- "$BLACKLIST_FILE"))) \
		-le 86400 ]] &&	return
	fi

	echo -ne "$blue::$nc$bold Downloading packages blacklist... $nc"

	if /usr/bin/curl -s "$BLACKLIST_SOURCE" \
	| /usr/bin/sed 's/  //g' \
	| /usr/bin/sudo -u "$user" /usr/bin/tee /tmp/blacklist_full \
	1> /dev/null; then
		echo -e "${green}OK$nc"

		if [[ $full_blacklist -eq 0 ]]; then

			# Parse the blacklist to remove technical and branding
			#+ nonfree packs
			/usr/bin/grep -- ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]\|^[^[]*$" \
			/tmp/blacklist_full | sudo -u "$user" \
			tee -- "$BLACKLIST_FILE" 1>/dev/null \
			|| exit $EXIT_FAILURE

			/usr/bin/rm /tmp/blacklist_full 2>/dev/null
		else
			/usr/bin/sudo -u "$user" /usr/bin/cp -- \
			/tmp/blacklist_full "$BLACKLIST_FILE" \
			|| exit $EXIT_FAILURE

			/usr/bin/rm /tmp/blacklist_full 2>/dev/null
		fi
	else
#		echoerr "${ME,,}: Error downloading file"
		exit $EXIT_FAILURE
	fi
}

################################

download_blacklist_aur ()
{
	if [[ -f $BLACKLIST_FILE_AUR ]]; then
		# If the blacklist file exists and it was last modified one
		#+ day ago or less, do nothing
		[[ $(($(/usr/bin/date "+%s") -  \
		$(/usr/bin/stat -c "%Y" -- "$BLACKLIST_FILE_AUR"))) \
		-le 86400 ]] &&	return
	fi

	echo -ne "$blue::$nc$bold Downloading packages blacklist" \
			 "(AUR)... $nc"

	if /usr/bin/curl -s -- "$BLACKLIST_SOURCE_AUR" \
	| /usr/bin/sed 's/  //g' \
	| /usr/bin/sudo -u "$user" /usr/bin/tee -- "$BLACKLIST_FILE_AUR" \
	1> /dev/null; then

		echo -e "${green}OK$nc"

	else
#		echoerr "${ME,,}: Error downloading file"
		exit $EXIT_FAILURE
	fi
}

################################

extra_alternatives ()
{
	local alternative_b=""
	declare -r pkg="$1"

	case $pkg in

		firefox|"firefox-dev"*|"firefox-i18n"*\
		|"firefox-beta"*|opera|chromium|"chromium-browser"*\
		|"google-chrome"*|vivaldi|falkon|seamonkey)
			alternative_b="icecat, iceweasel"
		;;

		"virtualbox"*|vmware-workstation) alternative_b="qemu" ;;

		"acroread"*|foxitreader) alternative_b="mupdf-gl" ;;

		dropbox) alternative_b="nextcloud" ;;

		atom|electron) alternative_b="eclipse, geany" ;;

		"nvidia"*) alternative_b="xf86-video-nouveau" ;;

		wps-office) alternative_b="libreoffice-fresh" ;;

		acetoneiso2) alternative_b="brasero, graveman, simpleburn" ;;

		clonezilla) alternative_b="mondo, partclone, partimage" ;;

		krusader) alternative_b="mc (from [libre])" ;;

	esac

	echo "$alternative_b"
}

################################

check_free ()
{
	# Check if called from the command line, namely, as '-f pkgs(s)'
	local external=0
	[[ -n $1 ]] && external=1

	if [[ ${#PKGS[*]} -eq 0 ]]; then
		# If there are no packages in PKGS, it means that whatever has been
		#+ passed as parameters in the command line it was not a valid
		#+ package name
		if [[ $external -eq 1 ]]; then
			echoerr "${ME,,}: No valid target specified"
			exit $EXIT_FAILURE
		fi

		return
	fi

	local pkgs_counter=${#PKGS[*]} repo="" pkg="" blacklisted="" \
	alternative="" description="" aur=0 source=""

	if [[ $external -eq 0 ]]; then
		echo -e "$blue::$nc$bold Checking packages against the" \
				"blacklist... $nc"
	fi

	for (( i=0; i<${#PKGS[*]}; i++ )); do

		repo=""; pkg=""; aur=0
		# If "repo/pkg", get the two values
		if [[ ${PKGS[$i]} == *"/"* ]]; then
			repo=${PKGS[$i]%%/*}
			pkg=${PKGS[$i]#*/}
		else
			pkg=${PKGS[$i]}
		fi

		# If "pkg-version", get package name
		if [[ $pkg == *">"* || $pkg == *"<"* ]]; then
			case $pkg in
				*">"*) pkg="${pkg%%>*}" ;;
				*"<"*) pkg="${pkg%%<*}" ;;
			esac
		fi

		# Check ignored packages
		if [[ $external -eq 1 ]]; then
			if is_ignored "$pkg"; then
				ign_list=(${ign_list[@]} "$pkg")
				continue
			fi
		fi

		if [[ -n $repo ]]; then
			case $repo in

				# If $repo is some of the Parabola's repos, skip the
				#+ test, since all packages here are supposed to be free
				libre|libre-multilib|kernels|pcr|cross|nonprism|\
				libre-testing|libre-multilib-testing|pcr-testing|\
				nonprism-testing)
					# Print the message only if called via -f. Otherwise
					#+ just skip the package
					if [[ $external -eq 1 ]]; then
						echo -e "$nc$bold${PKGS[$i]}$nc is" \
								"${green}not blacklisted$nc"
					fi
					continue
				;;

				# If not in Parabola's repos, check it against the
				#+ blacklist
				*) ;;
			esac
		fi

		# Check if $pkg is blacklisted
		blacklisted="$(/usr/bin/grep -- "^${pkg}:" "$BLACKLIST_FILE" \
		2>/dev/null)"

		# If the package is not blacklisted, and if some unofficial
		#+ repo is enabled or running via -f, check the AUR blacklist
		#+ as well
		if [[ -z $blacklisted && ($unofficial_repos -eq 1
		|| $external -eq 1) ]]; then
			blacklisted="$(/usr/bin/grep -- "^${pkg}:" \
			"$BLACKLIST_FILE_AUR" 2>/dev/null)"
			aur=1
		fi

		if [[ -n $blacklisted ]]; then

			# If blacklisted, get description and alternative pkg, if any
			description="$(echo "$blacklisted" | /usr/bin/cut -d":" -f5-10)"
			alternative="$(echo "$blacklisted" | /usr/bin/cut -d":" -f2)"

			# Parabola's blacklists lack alternative packages for non-free
			#+ soft that indeed has an alternative libre version. Here I add
			#+ a few of them for some popular packages
			if [[ -z $alternative ]]; then
				alternative="$(extra_alternatives "$pkg")"
			fi

			[[ aur -eq 0 ]] && source="official" || source="AUR"

			echo -e "$nc$bold$pkg$nc is a ${red}non-free$nc" \
					"package ($source blacklist)\n   Description:" \
					"$description\n   Free/libre alternative:" \
					"$alternative"

			# Ask only if not called via -f
			if [[ $external -eq 0 ]]; then
				local answer="." msg=""
				msg="$(echo -e "$blue::$nc$bold Do you want to install" \
					  "'${PKGS[$i]}' anyway? [y/N]$nc ")"

				while ! [[ $answer =~ ^(y|Y|n|N|)$ ]]; do
					read -rp "$msg" answer
				done

				case $answer in

					""|n|N)
						PKGS[$i]=""
						(( pkgs_counter-- ))
					;;

					y|Y) ;;
				esac
			fi

		else
			# Print the message only if called via -f
			if [[ $external -eq 1 ]]; then
				echo -e "$nc$bold${PKGS[$i]}$nc is" \
						"${green}not blacklisted$nc"
			fi
		fi
	done

	if [[ $external -eq 1 ]]; then
		[[ ${#ign_list[@]} -eq 0 ]] && exit $EXIT_SUCCESS
		if [[ ${#ign_list[@]} -eq 1 ]]; then
			echo -e "${red}[-]$nc 1 non-free/libre package ignored: ${red}${ign_list[*]}$nc"
		elif [[ ${#ign_list[@]} -gt 1 ]]; then
			echo -e "${red}[-]$nc ${#ign_list[@]} non-free/libre packages" \
				"ignored: ${red}${ign_list[*]}$nc"
		fi
		exit $EXIT_SUCCESS
	fi

	# If no pkg left after this check, just exit
	[[ $pkgs_counter -eq 0 ]] && exit $EXIT_SUCCESS

	# If no blacklisted packages found, $blacklisted will be emtpy
	if [[ -z $blacklisted ]]; then
		echo -e "$green ->$nc No blacklisted packages found"
	fi
}

################################

list_rules ()
{
	local rules=() rule=""

	mapfile -t rules < <(/usr/bin/grep -v -- "^$\|^#" "$RULES_FILE" \
	2>/dev/null)

	if [[ ${#rules[*]} -gt 0 ]]; then
		for rule in ${rules[*]}; do
			echo -e "$nc$bold${rule%%/*}/$green${rule##*/}$nc"
		done
	else
		echo -e "${ME,,}: No rules found (use '${ME,,} -a repo/pkg' to" \
				"add new rules)"
	fi
}

################################

print_version ()
{
	printf "%-23s$ME v%s (%s, by %s)\n%-23sLicense: \
%s\n%-23sWebsite: %s\n" "" "$VERSION" "$DATE" \
"$AUTHOR" "" "$LICENSE" "" "$WEBSITE"

	/usr/bin/"$PACMAN" --version || exit $EXIT_FAILURE
}

################################

check_added_functions ()
{
	case "$2" in

		# Modified version of pacman help (A)
		-h|--help)
			case "$1" in

				-f|--check-free) help "checkfree" ;;

				-a|--add-rule) help "addrule" ;;

				-d|--del-rule) help "delrule" ;;

				-L|--add-repo) help "addrepo" ;;

				-x|--del-repo) help "delrepo" ;;

				-l|--list-rules) help "listrules" ;;

				-r|--list-repos) help "listrepos" ;;

				-u|--upgrademe) help "upgrademe" ;;

				*) /usr/bin/"$PACMAN" "$1" --help ;;
			esac

			exit $EXIT_SUCCESS ;;
	esac

	case "$1" in

		# Modified version of pacman help (B)
		"")
			echoerr "${ME,,}: No operation specified (try '${ME,,} --help')"
			exit $EXIT_FAILURE
		;;

		-h|--help)
			help "help"
			exit $EXIT_SUCCESS
		;;

		-V|--version)
			print_version
			exit $EXIT_SUCCESS
		;;

		# Added functions
		-f|--check-free)

			download_blacklist
			download_blacklist_aur

			# If no package specified, check the entire system
			if [[ -z $2 ]]; then
				check_sys_free
			# Otherwise, check only specified packages
			else
				unofficial_repos=1
				check_free "external"
			fi

			exit $EXIT_SUCCESS
		;;

		-a|--add-rule)
			shift
			add_rule "$@"
			exit $EXIT_SUCCESS
		;;

		-d|--del-rule)
			shift
			del_rule "$@"
			exit $EXIT_SUCCESS
		;;

		-l|--list-rules)
			list_rules
			exit $EXIT_SUCCESS
		;;

		-L|--add-repo)
			shift
			add_libre_repos "$@"
			exit $EXIT_SUCCESS
		;;

		-x|--del-repo)
			shift
			del_repo "$@"
			exit $EXIT_SUCCESS
		;;

		-r|--list-repos)
			shift
			list_repos "$@"
			exit $EXIT_SUCCESS
		;;

		-u|--upgrademe)
			upgrade_me
			exit $EXIT_SUCCESS
		;;
	esac
}

################################

del_repo ()
{
	local repos=() repo="" delrepos=() found=0

	delrepos=( "$@" )

	repos=( "libre" "libre-multilib" "pcr" "kernels" "cross" "nonprism" \
	"libre-testing" "libre-multilib-testing" "pcr-testing" \
	"nonprism-testing" )

	for delrepo in ${delrepos[*]}; do

		found=0

		# Check we have an existent libre repo
		for repo in ${repos[*]}; do
			if [[ $delrepo == "$repo" ]]; then
				found=1
				break
			fi
		done

		if [[ $found -eq 0 ]]; then
			echoerr "${ME,,}: '$delrepo': No such libre repository"
			continue
		fi

		# Check we have an enabled repo
		if ! [[ "$(/usr/bin/pacman-conf -r "$delrepo" 2>/dev/null)" ]]; then
			echoerr "${ME,,}: [$delrepo]: Repository not enabled"
			continue
		fi

		# If valid and enabled, disable it
		local repo_found=0 counter=0 lines=""

		# Get the line numbers in pacman config file for the repository
		#+ to be disabled. They will be passed later to sed
		while IFS=$' \t\n' read -r line; do
			(( counter++ ))
			if [[ $repo_found -eq 0 && $line == "[$delrepo]" ]]; then
				repo_found=1
			fi

			if [[ $repo_found -eq 1 ]]; then
				case $line in
					"[$delrepo]" ) ;;
					""|"#"*) continue ;;
					"["*"]") break ;;
				esac

				# Store line number in sed format
				lines="$lines;${counter}d"
			fi

		done < "$PACMAN_CONF_FILE"

		# This should never happen
		if [[ $repo_found -eq 0 ]]; then
			echoerr "${ME,,}: [$delrepo]: Repository not found"
			exit $EXIT_FAILURE
		fi

		echo -e "$blue::$nc$bold Removing [$delrepo] repository" \
				"from $PACMAN_CONF_FILE...$nc "

		# Remove the lines corresponding to the repo to be disabled from
		#+ pacman config file. "${lines:1}" removes the leading semicolon
		#+ from the sed line, and cat -s removes duplicated blank lines
		#+ from the file
		# NOTE: I would be better to find a way of doing this while
		#+ preserving file attributes
		/usr/bin/sed "${lines:1}" -- "$PACMAN_CONF_FILE" | /usr/bin/cat -s \
		| /usr/bin/sudo /usr/bin/tee -- "$PACMAN_CONF_FILE" 1>/dev/null

		/usr/bin/sudo /usr/bin/pacman -Sy

		# Remove the database files as well
		/usr/bin/sudo /usr/bin/rm -- \
		/var/lib/pacman/sync/"$delrepo".{files,db} 2>/dev/null

	done
}

################################

upgrade_me ()
{
	if ! [[ "$(type -P /usr/bin/vercmp)" ]]; then
		echoerr "${ME,,}: 'vercmp': Command not found"
		exit $EXIT_FAILURE
	fi

	declare -r RAW_URL="https://raw.githubusercontent.com/leo-arch/pacfree/master/pacfree"
	local upstream_version=""

	upstream_version="$(/usr/bin/curl -s -- "$RAW_URL" \
	| /usr/bin/grep ^"VERSION=" | /usr/bin/cut -d'=' -f2 \
	| /usr/bin/sed 's/"//g')"

	if [[ -z $upstream_version ]]; then
		echoerr "${ME,,}: Could not connect to server. Try again or visit" \
		"$WEBSITE"
		exit $EXIT_FAILURE
	fi

	# vercmp does not support "--"
	local res="$(/usr/bin/vercmp "$upstream_version" "$VERSION")"
	if [[ $res -gt 0 ]]; then
		echo "${ME,,}: Available upgrade ($upstream_version)"
	elif [[ $res -eq 0 ]]; then
		echo "$ME ($VERSION) is up to date"
	else
		echo "$ME ($VERSION) is newer than upstream ($upstream_version)"
	fi
}

################################

list_repos ()
{
	if ! [[ -f "$PACMAN_CONF_FILE" ]]; then
		echoerr "${ME,,}: $PACMAN_CONF_FILE: No such file or" \
				"directory"
		exit $EXIT_FAILURE
	fi

	if [[ -n "$1" ]]; then
		for i in "$@"; do
			if /usr/bin/grep -q -- "^\[$i\]" "$PACMAN_CONF_FILE"; then
				echo -e "${green}[+]$nc [$i]: Enabled"
			else
				echo -e "${ME,,}: [$i]: No such repository"
			fi
		done
	else
		/usr/bin/grep -- "^\[.*\]" "$PACMAN_CONF_FILE" \
		| /usr/bin/grep -v "options" | /usr/bin/tr -d "\[\]"
		# Or just '/usr/bin/pacman-conf -l'
	fi
}

################################

del_rule ()
{
	local del_rules=() err=0

	del_rules=( "$@" )

	for rule in ${del_rules[*]}; do

		if ! /usr/bin/grep -q -- ^"$rule"$ "$RULES_FILE"; then
			echoerr "${ME,,}: '$rule': No such rule"
			(( err++ ))
			continue
		elif /usr/bin/sed -i "/^${rule/\//\\\/}$/d" -- "$RULES_FILE"; then
			echo -e "${green}[+]$nc '$rule': Rule successfully removed"
		else
			(( err++ ))
		fi

	done

	[[ $err -gt 0 ]] && exit $EXIT_FAILURE
}

################################

add_rule ()
{
	if [[ -z $1 ]]; then
		echoerr "${ME,,}: No rule specfied (try '${ME,,} -a --help')"
		exit $EXIT_FAILURE
	fi

	local repo="" rule="" pkg_name=""

	for rule in "$@"; do

		repo=""; pkg_name=""

		if [[ $rule == *"/"* ]]; then

			repo="${rule%%/*}"

			# Check if repo is a valid repo
			if ! [[ "$(/usr/bin/pacman-conf -r "$repo" \
			2>/dev/null)" ]]; then
				echoerr "${ME,,}: '$repo': No such repository"
				continue
			fi

			# Check if pkg name is a valid pkg name
			pkg_name="${rule#*/}"

			if valid_pkg_name "$pkg_name" -eq 0; then :
			else
				echoerr "${ME,,}: '$pkg_name': Not a valid package name"
				continue
			fi

		else
			echoerr "${ME,,}: '$rule': A repository must be" \
					"specified. Example: 'repo/$rule'"
			continue
		fi

		if /usr/bin/grep -q -- "$rule" "$RULES_FILE"; then
			echoerr "${ME,,}: '$rule': Rule already exists"
			continue
		else
			echo "$rule" | /usr/bin/sudo -u "$user" /usr/bin/tee -a -- \
			"$RULES_FILE" 1>/dev/null || exit $EXIT_FAILURE

			echo -e "${green}[+]$nc '$rule': Rule successfully added"
		fi
	done
}

################################

print_logs ()
{
	declare -r LOG_FILE="/var/log/pacman.log"

	if [[ -z $1 ]]; then
		/usr/bin/cat -- "$LOG_FILE" || exit $EXIT_FAILURE

	else
		local args=() filter="" grep_color=""
		args=( "$@" )
		for (( i=0; i<${#args[*]}; i++ )); do
			[[ $i -eq 0 ]] && filter="${args[$i]}" && continue
			[[ ${args[$i]} == "-"* ]] && continue
			filter="$filter\|${args[$i]}"
		done

		if [[ $color_ok -eq 1 ]]; then
			grep_color="--color=always"
		else
			grep_color="--color=never"
		fi

		/usr/bin/grep "$grep_color" -- "$filter" "$LOG_FILE" \
		|| exit $EXIT_FAILURE
	fi
}

################################

parse_arguments ()
{
	local sync_index=-1 process_args=1

	# Process arguments
	for (( i=0; i<${#p[*]}; i++ )); do

		# Stop processing options if "--" is found
		if [[ ${p[$i]} == "--" && process_args -eq 1 ]]; then
			process_args=0
			continue
		fi

		[[ $process_args -eq 0 ]] && continue

		case ${p[$i]} in

			# Handle color
			"--color="*)
				case ${p[$i]##*=} in
					never)
						yellow=""; green=""; red=""; blue=""; bold=""
						nc=""; pacman_color="--color=never"; color_ok=0
					;;
					always) pacman_color="--color=always"; color_ok=1 ;;
					auto) pacman_color="--color=auto"; color_ok=1 ;;
					*) pacman_color="--color=auto"; color_ok=1 ;;
				esac

				# Remove the argument: we don't want to pass it to pacman
				p[$i]=""
			;;

			-nc) # Short for --color=never
				p[$i]=""; yellow=""; green=""; red=""; blue=""; bold=""
				nc=""; pacman_color="--color=never"; color_ok=0
			;;

			-b|--full-blacklist)
				p[$i]=""; full_blacklist=1
				case ${p[$i+1]} in
					-h|--help)
						help "fullblacklist"
						exit $EXIT_SUCCESS ;;
				esac
			;;

			# Allow some APT/DNF syntax for users coming from
			#+ Debian/RedHat based systems.

			# Pacman operations
			install|i) p[$i]="-S" ;;
			install-local|il) p[$i]="-U" ;;
			remove|r) p[$i]="-Rns" ;;
			update|refresh|u) p[$i]="-Sy" ;;
			upgrade|sysupgrade|s) p[$i]="-Su" ;;
			search|query|q) p[$i]="-Ss" ;;
			list-installed|li) p[$i]="-Qe" ;;
			list-installed-native|lin) p[$i]="-Qen" ;;
			list-installed-foreign|lif) p[$i]="-Qem" ;;
			list-installed-deps|lid) p[$i]="-Qd" ;;
			list-no-required|lnr) p[$i]="-Qt" ;;
			info|n) p[$i]="-Qi" ;;
			info-remote|nr) p[$i]="-Si" ;;
			list-files|lf) p[$i]="-Ql" ;;
			provides|p) p[$i]="-Qo" ;;
			provides-remote|pr) p[$i]="-F" ;;
			check|k) p[$i]="-Qk" ;;
			clean|c) p[$i]="-Sc" ;;
			clean-all|ca) p[$i]="-Scc" ;;
			download|d) p[$i]="-Sw" ;;

			# Pacfree operations
			check-free|cf) p[$i]="-f" ;;
			add-rule|ar) p[$i]="-a" ;;
			del-rule|dr) p[$i]="-d" ;;
			list-rules|lr) p[$i]="-l" ;;
			add-repo|al) p[$i]="-L" ;;
			del-repo|dl) p[$i]="-x" ;;
			list-repos|ll) p[$i]="-r" ;;

			list-updates|lu)
				list_updates
				exit $EXIT_SUCCESS
			;;

			help)
				help "help"
				exit $EXIT_SUCCESS
			;;
			version)
				print_version
				exit $EXIT_SUCCESS
			;;
			history|logs|l)
				print_logs ${p[*]:1}
				exit $EXIT_SUCCESS
			;;
		esac

		# Use a second case statement to be able to catch the string
		#+ (possibily) modified in the previous case statement
		case ${p[$i]} in

			# Catch sync, refresh (-y) and sysupgrade (-u) options

			# Increment variable to intercept both -yy (force update)
			#+ and -uu (allow downgrades)
			--refresh|-y) (( do_update++ )) ;;

			--sysupgrade|-u) (( do_sysupgrade++ )) ;;

			"-S"*)
				sync_value="${p[$i]}"
				sync_index=$i

				local res=""
				if [[ $sync_value == *'y'* ]]; then
					res="${sync_value//[^y]}"
					do_update=$((do_update+${#res}))
				fi

				if [[ $sync_value == *'u'* ]]; then
					res="${sync_value//[^u]}"
					do_sysupgrade=$((do_sysupgrade+${#res}))
				fi
			;;

			--sync)
				sync_value="${p[$i]}"
				sync_index=$i
			;;
		esac

	done

	if [[ -z $sync_value ]]; then
		no_install=1

	# Check non-install SHORT suboptions (c,g,h,i,l,s,w,p) for --sync.
	# None of these sync suboptions are intended for software
	#+ installation. So, if some of them is found in the sync string,
	#+ set $no_install to 1, so that check_free() and check_rules(),
	#+ only valid for packages installation, won't be executed.
	#+ Drawback: This might break things if $PACMAN is not pacman,
	#+ powerpill or yay.
	elif [[ $sync_value == "-S"* && $(echo "$sync_value" \
	| /usr/bin/grep "[c,g,h,i,l,s,w,p]") ]]; then
		no_install=1
	fi
	###############

	process_args=1

	for (( i=0; i<${#p[*]}; i++ )); do

		################################################
		# Stop processing options if "--" is found
		if [[ ${p[$i]} == "--" && process_args -eq 1 ]]; then
			process_args=0
			continue
		fi

		if [[ $process_args -eq 0 ]]; then
			#+ From now on, everything is treated as a package 
			PKGS[${#PKGS[*]}]="${p[$i]}"
			continue
		fi
		###############################################

		[[ $i -eq $sync_index ]] && continue

		# Check non-install LONG suboptions for --sync.
		if [[ -n $sync_value ]]; then
			case ${p[$i]} in
				--clean|--groups|--help|--info|--list|--search\
				|--downloadonly|--print)
					no_install=1
				;;
			esac
		fi

		# Whatever is a valid package name goes to PKGS. Everything
		#+ else goes to OPTS
		if [[ ${p[$i]} == '-'* ]]; then
			OPTS[${#OPTS[*]}]="${p[$i]}"
		else
			if valid_pkg_name "${p[$i]}" -eq 0; then
				PKGS[${#PKGS[*]}]="${p[$i]}"
			else
				OPTS[${#OPTS[*]}]="${p[$i]}"
			fi
		fi

	done
}

################################

list_updates ()
{
	if [[ "$(type -P /usr/bin/checkupdates)" ]]; then

		echo -e "$blue::$nc$bold Checking available" \
				"upgrades... $nc"
		/usr/bin/checkupdates || exit $EXIT_FAILURE

	else

		echoerr "${yellow}Warning:$nc 'checkupdates' is the recommended" \
				"tool for this operation"

		local options="--color=auto"
		[[ $color_ok -eq 0 ]] && options="--color=never"
		/usr/bin/sudo /usr/bin/pacman "$options" -Sy \
		|| exit $EXIT_FAILURE

		echo -e "$blue::$nc$bold Available" \
				"upgrades: $nc"
		/usr/bin/pacman "$options" -Qu \
		|| exit $EXIT_FAILURE
	fi
}

################################

check_rules ()
{
	[[ ${#PKGS[*]} -eq 0 ]] && return

	local rules=() RULED_PKGS=() pkg_name="" pkg_version=""

	### LOAD REPO RULES ###

	mapfile -t rules < <(/usr/bin/grep -v -- "^$\|^#" "$RULES_FILE" \
	2>/dev/null)

	echo -e "$blue::$nc$bold Checking packages against rules...$nc "

	if [[ ${#rules[*]} -eq 0 ]]; then
		echo -e "$yellow ->$nc No rules defined"
		return
	fi

	### CHECK PKGS AGAINST RULES ###

	for (( i=0; i<${#PKGS[*]}; i++ )); do

		pkg_name=""; pkg_version=""

		# If repo was already specified in command line (repo/pkg),
		#+ skip the rules test
		if [[ ${PKGS[$i]} == *"/"* ]]; then
			continue
		fi

		pkg_name=${PKGS[$i]}

		# Get package name from version expressions
		if [[ ${PKGS[$i]} == *"<"* || ${PKGS[$i]} == *">"* ]]; then
			case ${PKGS[$i]} in
				*"<"*)
					pkg_name="${PKGS[$i]%%<*}"
					pkg_version="<${PKGS[$i]#*<}"
				;;
				*">"*)
					pkg_name="${PKGS[$i]%%>*}"
					pkg_version=">${PKGS[$i]#*>}"
				;;
			esac
		fi

		for (( j=0; j<${#rules[*]}; j++ )); do
			if [[ $pkg_name == "${rules[$j]#*/}" ]]; then

				if [[ -n $pkg_version ]]; then
					PKGS[$i]="${rules[$j]}$pkg_version"
					RULED_PKGS[${#RULED_PKGS[*]}]="${rules[$j]}$pkg_version"
				else
					PKGS[$i]="${rules[$j]}"
					RULED_PKGS[${#RULED_PKGS[*]}]="${rules[$j]}"
				fi

				break
			fi
		done
	done

	if [[ ${#RULED_PKGS[*]} -gt 0 ]]; then
		echo -e "$green ->$nc Ruled packages found:"
		for (( i=0; i<${#RULED_PKGS[*]}; i++ )); do
			echo " $((i+1))) ${RULED_PKGS[$i]}"
		done
	else
		echo -e "$green ->$nc No ruled packages found"
	fi
}

################################

check_updates ()
# The main trick of this function is to grab all packages to be
#+ upgraded to be later checked against the rules list and finally
#+ installed via the -S option.
{
	# Check sync_value looking for (y,--refresh) and
	#+ (u,--sysupgrade)

	[[ -z $sync_value ]] && return

	if [[ $do_sysupgrade -gt 1 ]]; then
		echoerr "${ME,,}: Downgrades are not currently supported"
		exit $EXIT_FAILURE
	fi

	local tmp=""

	### UPDATE/REFRESH ###

	# The program functionality does not require to update the databases
	#+ now: the update would be performed after the checks anyway (with
	#+ the pacman command at the end of main()). However, since pacman's
	#+ normal procedure is to perform the updates before anything else, I
	#+ prefer to stick to this standard and execute the update now, before
	#+ the checks.

	# If refresh, well, refresh the database
	if [[ $do_update -gt 0 ]]; then

		if [[ $do_sysupgrade -eq 0 && ${#PKGS[*]} -gt 0 ]]; then
			echoerr "${yellow}Warning$nc: Partial upgrades are" \
					"unsupported. Use '-Syu' instead of '-Sy'"
		fi

		# If -S, remove '-y' from sync options
		# We must also remove -u, if there, since we don't want to
		#+ upgrade the system before performing the corresponding checks
		if [[ $sync_value == "-S"* && $sync_value == *'y'* ]]; then
			tmp="${sync_value//[y,u]}"
			sync_value="$tmp"
		fi

		# If --sync (or -S --opts), remove "--refresh, -y" and
		#+ "--sysupgrade, -u" from the OPTS array
		OPTS=( "${OPTS[*]//--refresh}" )
		OPTS=( "${OPTS[*]//-y}" )
		OPTS=( "${OPTS[*]//--sysupgrade}" )
		OPTS=( "${OPTS[*]//-u}" )

		# If -Syy, force the databases refresh
		if [[ $do_update -gt 1 ]]; then
			/usr/bin/pacman $pacman_color ${OPTS[*]} "$sync_value" \
			-yy || exit $EXIT_FAILURE
		else
			/usr/bin/pacman $pacman_color ${OPTS[*]} "$sync_value" \
			-y || exit $EXIT_FAILURE
		fi
	fi

	### SYSTEM UPGRADE ###

	if [[ $do_sysupgrade -eq 0 ]]; then
		# If no sysupgrade, no packages to be installed (-Sy), and no
		#+ extra option, there is nothing else to do

		if [[ ${#PKGS[*]} -eq 0 \
		&& (${#sync_value} -lt 3 || ${OPTS[*]} != *"--clean"*) ]]; then
			exit $EXIT_SUCCESS

		# If no sysupgrade but there are packages to install
		#+ (-Sy pkgs(s)), return to continue performing checks
		else
			return
		fi
	fi

	# At this point, we know the user requested a system upgrade (but we
	#+ stil don't know if there are actually available upgrades)

	# Remove 'u' from sync options
	if [[ $sync_value == "-S"* && $sync_value == *"u"* ]]; then
		tmp="${sync_value//u}"
		sync_value="$tmp"
	fi

	OPTS=( "${OPTS[*]//--sysupgrade}" )
	OPTS=( "${OPTS[*]//-u}" )

	# Remove leading, trailing, and double spaces from OPTS
	OPTS=( "${OPTS[*]##*( )}" )
	OPTS=( "$(echo "${OPTS[*]%%*( )}" | /usr/bin/tr -s ' ')" )

	# If no update (only upgrade), that is, if -Su, update anyway
#	if [[ $do_update -eq 0 ]]; then
#		# Get available upgrades (update the database)
#		/usr/bin/pacman $pacman_color ${OPTS[*]} "$sync_value" -y \
#		|| exit $EXIT_FAILURE
#	fi

	# Get pkgs to be upgraded
	local ups=()

	mapfile -t ups < <(/usr/bin/pacman -Qu | /usr/bin/grep -v \
	"\[ignored\]" | /usr/bin/awk '{print $1}')

	# If no upgrades...
	if [[ ${#ups[*]} -eq 0 ]]; then
		# and no packages to be installed, exit
		if [[ ${#PKGS[*]} -eq 0 ]]; then
			echo "There is nothing to do"
			exit $EXIT_SUCCESS
		else
			if [[ $do_sysupgrade -eq 1 ]]; then
				echo -e "$green ->$nc$bold There are no available" \
						"upgrades$nc"
			fi
			return
		fi
	fi

	# At this point, we know there are upgrades

	# If only upgrading (no pkgs to install), set the only_upgrade flag to 1,
	#+ so that check_free() won't be executed
	[[ ${#PKGS[*]} -eq 0 ]] && only_upgrade=1

	# Append packages to be upgraded to the PKGS array
	for up in ${ups[*]}; do
		PKGS[${#PKGS[*]}]="$up"
	done

	# And finally, list available upgrades
	echo -e "$blue::$nc$bold Available upgrades:$nc "
	/usr/bin/pacman $pacman_color -Qu || exit $EXIT_FAILURE
}

################################

init_config ()
{
	# If pacman is not installed, this program is useless
	if ! [[ "$(type -P /usr/bin/pacman)" ]]; then
		echoerr "${ME,,}: pacman: Command not found"
		exit $EXIT_FAILURE
	fi

	# NOTE: curl is a dependency of pacman, so that there is no need to
	#+ check for it

	[[ $SUDO_USER ]] && user=$SUDO_USER || user=$USER
	if [[ -z $user ]]; then
		echoerr "${ME,,}: Unable to get current username"
		exit $EXIT_FAILURE
	fi

	### GENERATE CONFIG FILES AND DIRECTORIES ###

	if [[ $user == "root" ]]; then
		CONFIG_DIR="/root/.config/${ME,,}"
	else
		CONFIG_DIR="/home/$user/.config/${ME,,}"
	fi

	CONFIG_FILE="$CONFIG_DIR/${ME,,}.conf"

	RULES_FILE="$CONFIG_DIR/rules.conf"

	if ! [[ -d "$CONFIG_DIR" ]]; then
		/usr/bin/sudo -u "$user" /usr/bin/mkdir -pm 700 -- "$CONFIG_DIR" \
		|| exit $EXIT_FAILURE
	fi

	if ! [[ -f "$CONFIG_FILE" ]]; then
		echo -e "# $ME configuration file

# If set to false, remove packages with trademarking and merely
# technical issues from the blacklist (these packages are in themselves
# free, so we don't really want them in the blacklist)
full_blacklist=false

# Define your package manager, say 'pacman', 'powerpill', 'yay', etc.
# This is an experimental feature. If not using pacman, use it at your own
# risk
pac_man=pacman

# Colorize output
color=true

# Enable or disable $ME checks for packages. Though disabling both
# checks would make $ME useless, it might be usefull in some cases
check_rules=true
check_free=true

# Comma separated list of packages to be ignored during the free
# packages check (-f)
#ignore=\"pkg1,pkg2\"
" | /usr/bin/sudo -u "$user" /usr/bin/tee -- "$CONFIG_FILE" 1>/dev/null \
|| exit $EXIT_FAILURE

	/usr/bin/chmod 600 -- "$CONFIG_FILE"

	fi

	if ! [[ -f "$RULES_FILE" ]]; then
		echo "# Repository rules for $ME

# Add here repository rules for packages, one per line, in the
# form 'repo/pkg' (blank and commented lines are ommited). Packages
# listed here will always be installed/upgraded from the specified
# repository (disregarding its place in the pacman configuration file).
# Example:
# core/filesystem
# libre/licenses
" | /usr/bin/sudo -u "$user" /usr/bin/tee -- "$RULES_FILE" 1>/dev/null \
|| exit $EXIT_FAILURE

	/usr/bin/chmod 600 -- "$RULES_FILE"

	fi

	### READ THE CONFIG FILE ###

	local full_bl_value="" color="" rules_value="" free_value=""

	full_bl_value="$(/usr/bin/grep -- "^full_blacklist=" \
	"$CONFIG_FILE" | /usr/bin/cut -d"=" -f2)"

	case $full_bl_value in
		true) full_blacklist=1 ;;
		false) full_blacklist=0 ;;
		*) full_blacklist=0 ;; # Default value
	esac

	PACMAN="$(/usr/bin/grep -- "^pac_man=" "$CONFIG_FILE" \
	| /usr/bin/cut -d"=" -f2)"

	# Get the list of ignored packages, if any
	OLD_IFS="$IFS"
	IFS=","
	read -ra IGNORED <<< "$(/usr/bin/grep ^"ignore=" "$CONFIG_FILE" | /usr/bin/cut -d\" -f2)"
	IFS="$OLD_IFS"

	if [[ -z $PACMAN ]]; then
		PACMAN="pacman"
	elif ! [[ "$(type -P /usr/bin/"$PACMAN")" ]]; then
		echoerr	"${ME,,}: $PACMAN: Command not found"
		exit $EXIT_FAILURE
	fi

	if [[ $PACMAN != "pacman" ]]; then
		echoerr "${yellow}Warning$nc: '$PACMAN': The use of package" \
				"managers other than pacman is not fully supported. Use" \
				"it at your own risk"
#		read -rsp "Press Enter to continue or Ctrl-c to exit... "
	fi

	color="$(/usr/bin/grep -- "^color=" "$CONFIG_FILE" \
	| /usr/bin/cut -d"=" -f2)"

	case $color in
		true) color_ok=1 ;;
		false) color_ok=0 ;;
		*) color_ok=1 ;;
	esac

	if [[ $color_ok -eq 0 ]]; then
		yellow=""; green=""; red=""; blue=""; bold=""; nc=""

		# Disable color for /usr/bin/pacman as well
		pacman_color="--color=never"
	fi

	rules_value="$(/usr/bin/grep -- "^check_rules=" "$CONFIG_FILE" \
	| /usr/bin/cut -d"=" -f2)"

	case $rules_value in
		true) rules_ok=1 ;;
		false) rules_ok=0 ;;
		*) rules_ok=1 ;;
	esac

	free_value="$(/usr/bin/grep -- "^check_free=" "$CONFIG_FILE" \
	| /usr/bin/cut -d"=" -f2)"

	case $free_value in
		true) free_ok=1 ;;
		false) free_ok=0 ;;
		*) free_ok=1 ;;
	esac
}

################################

valid_pkg_name ()
{
# From the Wiki:
# "Package names can contain only alphanumeric characters and any
#+ of @ . _ + -
#+ Names are not allowed to start with hyphens or dots. All letters
#+ should be lowercase."

	local pkg_name="$1" res="" tmp=""

	# At most, a package expression could contain 1 slash, like in
	#+ "repo/pkg". If more than one, it's not a valid expression
	res=${pkg_name//[^\/]}
	[[ ${#res} -gt 1 ]] && return $EXIT_FAILURE

	case $pkg_name in

		# Get pkg name in version expressions: "foo>1.2.3"
		*'<'*)
			tmp="${pkg_name%%<*}"
			pkg_name="$tmp"
		;;

		*'>'*)
			tmp="${pkg_name%%>*}"
			pkg_name="$tmp"
		;;

		# No valid package expression ends or starts with a slash.
		#+ If there is a slash, it should be in the middle, like
		#+ "repo/pkg"
		'/'*|*'/') return $EXIT_FAILURE ;;
	esac

	# Get pkg name in repo expressions: "repo/pkg"
	if [[ $pkg_name == *'/'* ]]; then

		# If there is a slash in the middle of the string, check
		#+ it is not a filename
		if [[ -e "$pkg_name" ]]; then
			return $EXIT_FAILURE

		# If not a filename, take whatever comes after the first slash
		#+ as the package name
		else
			tmp="${pkg_name#*/}"
			pkg_name="$tmp"
		fi
	fi

	[[ -z "$pkg_name" ]] && return $EXIT_FAILURE

	# Now perform the checks for package names validity

	case $pkg_name in

		# If it starts with a hyphen or a dot, it's not a valid
		#+ package name
		'-'*|'.'*) return $EXIT_FAILURE ;;

		# Exclude strings only valid for the --architecture option
		i[3-6]86|pentium4|x86_64|any|armv[5-8]h)
			if [[ ${p[*]} == *"--arch"?"${p[$i]}"* ]]; then
				return $EXIT_FAILURE
			fi
		;;

		auto)
			if [[ ${p[*]} == *"--arch"?"${p[$i]}"* \
			|| ${p[*]} == *"--color"?"${p[$i]}"* ]]; then
				return $EXIT_FAILURE
			fi
		;;

		# Exclude strings only valid for the --color option
		always|never)
			if [[ ${p[*]} == *"--color"?"${p[$i]}"* ]]; then
				return $EXIT_FAILURE
			fi
		;;
	esac

	# Make sure the package is not an argument to the --ignore or
	#+ --ignoregroup directives
	if [[ ${p[*]} == *"--ignore"?"${p[$i]}"* \
	|| ${p[*]} == *"--ignoregroup"?"${p[$i]}"* ]]; then
		return $EXIT_FAILURE
	fi

	# Exclude valid pkg name chars from pkg_name. If something remains,
	#+ it's not a valid package name
	if [[ $(echo "$pkg_name" \
	| /usr/bin/sed 's/[a-z0-9]\|[,@+-./]//g') ]]; then
		return $EXIT_FAILURE
	else
		return $EXIT_SUCCESS
	fi
}

################################

check_unofficial_repos ()
{
	# Remove official repos from the repos list. If something remains,
	#+ it's unofficial
	if /usr/bin/grep -- "^\[" "$PACMAN_CONF_FILE" \
	| /usr/bin/grep -qv -- "options\|core\|extra\|community\|community-testing\|multilib\|multilib-testing\|testing\|gnome-unstable\|kde-unstable"; then
		unofficial_repos=1

	# Pacman wrappers like yay or trizen can install packages from the
	#+ AUR, which, of course, is unofficial.
	elif [[ $PACMAN != "pacman" && $PACMAN != "powerpill" ]]; then
		unofficial_repos=1
	fi
}

########################################################################

						#####################
						#       MAIN        #
						#####################

########################################################################

main ()
{
	p=( "$@" ) # Command line arguments

	### GLOBAL VARIABLES ###

	PKGS=() # List of packages to operate on
	OPTS=() # Everything that is not a package (except the sync string)
	IGNORED=() # List of ignored packages (no free-software check (-f) for them)

	user="" # User running the program
	sync_value="" # Sync string. Ex: -Syu or --sync
	# Should we install/upgrade some package? If not, check_free()
	#+ and check_rules() won't be executed
	no_install=0
	# If only upgrading, that is, if not installing any extra package,
	#+ we should not run check_free()
	only_upgrade=0
	# Catch "-y,--refresh" and "-u,--sysupgrade" options
	do_update=0
	do_sysupgrade=0
	# Is the user using some unofficial repo or some package manager
	#+ able to install packages from the AUR? In this case, we should
	#+ use the AUR blacklist as well
	unofficial_repos=0

	## CONFIG FILE OPTIONS ##

	# Should we use the complete blacklist or a trimmed down
	#+ version without packages marked as non-free merely because
	#+ of branding and technical issues?
	full_blacklist=0

	color_ok=1 # We colorize output by default
	# The "auto" value for --color makes pacman to enable color only
	#+ when outputting onto a tty
	pacman_color="--color=auto"

	rules_ok=1 # Should we perform the rules check?
	free_ok=1 # Should we perform the free package check?

	### GET/CREATE CONFIGURATION DIRECTORIES AND FILES ###
	init_config

	### GET OPTIONS, SYNC VALUE, AND PKGS TO BE INSTALLED
	#+ FROM INPUT ###
	# Pkgs to be installed are added to PKGS
	parse_arguments

	### CHECK FOR ADDED FUNCTIONS ###
	# Repo rules stuff, modified help, and libre repositories
	check_added_functions ${p[*]}

	### DOWNLOAD THE BLACKLISTS ###
	# Only if there is something to install and/or upgrade
	if [[ -n $sync_value && $no_install -eq 0 ]]; then
		download_blacklist
		check_unofficial_repos
		[[ $unofficial_repos -eq 1 ]] && download_blacklist_aur
	fi

	# This block is only for my personal configuration. You can
	#+ comment it if you like. However, it won't do anything if
	#+ /tmp/updates doesn't exist. If by chance it exists, this
	#+ block only writes a zero to the file.
	if [[ $do_sysupgrade -eq 1 && -f /tmp/updates ]]; then
		echo "0" | /usr/bin/sudo -u "$user" \
		/usr/bin/tee /tmp/updates 1>/dev/null
	fi

	### CHECK FOR UPDATES ###
	# Pkgs to be upgraded, if any, are added to PKGS
	if [[ $do_update -gt 0 || $do_sysupgrade -gt 0 ]]; then
		check_updates
	fi

	### REMOVE DUPLICATED PACKAGES (just in case) ###
	local tmp=()

	mapfile -t tmp < <(for i in ${PKGS[*]}; do echo "$i"; done \
	| /usr/bin/sort -mu)

	PKGS=( ${tmp[*]} )
	unset tmp

	# $no_install was set above, in parse_arguments()
	# $no_install includes both upgrades and new packages
	if [[ $no_install -eq 0 ]]; then
		### CHECK PKGS AGAINST REPO RULES ###
		# If some rule is found for a package, the package name in
		#+ PKGS is replaced by the rule (repo/pkg)
		[[ $rules_ok -eq 1 ]] && check_rules

		### CHECK PACKAGES AGAINST THE BLACKLIST ###
		# Non-free/allowed pkgs are removed from PKGS
		if [[ $free_ok -eq 1 && $only_upgrade -eq 0 ]]; then
			check_free
		fi
	fi

	### FIRE UP THE PACMAN ###

	if [[ $do_sysupgrade -eq 1 ]]; then
		if [[ $only_upgrade -eq 1 ]]; then
			echo -e "$blue::$nc$bold Starting full system" \
					"upgrade...$nc"
		else
			echo -e "$blue::$nc$bold Starting full system" \
					"upgrade and installing new packages...$nc"
		fi
	fi

	/usr/bin/"$PACMAN" $pacman_color ${OPTS[*]} $sync_value -- \
	${PKGS[*]} || exit $EXIT_FAILURE

}

################################

main "$@"

exit $EXIT_SUCCESS
